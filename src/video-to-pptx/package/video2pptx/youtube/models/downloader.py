import os
import pathlib
import random
import typing
from dataclasses import dataclass

import validators
from pytube import Stream, StreamQuery, YouTube
from slugify import slugify

from video2pptx.base.datamodels.video import VideoResolution
from video2pptx.base.models import BaseDownloader
from video2pptx.utils.typing import strOrPath
from video2pptx.youtube.datamodels.caption import xml_caption_to_srt
from video2pptx.youtube.datamodels.video import YouTubeVideoMetadata


_URL_youtube = "https://youtube.com/watch?v="


def _choose_stream(streams: StreamQuery, resolution: VideoResolution) -> Stream:
    """It chooses a stream among many given the desired resolution"""
    if resolution == VideoResolution.lowest:
        return streams.get_lowest_resolution()

    if resolution == VideoResolution.highest:
        return streams.get_highest_resolution()

    if resolution != VideoResolution.random:
        stream = None

        while stream is None and resolution is not None:
            stream = streams.get_by_resolution(str(resolution))

            # It traverses the resolution hierarchy
            resolution = resolution.prev

        if stream is not None:
            return stream

    num_streams = streams.count
    idx = random.randint(0, num_streams - 1)

    return streams.all()[idx]


@dataclass
class YouTubeDownloader(BaseDownloader):
    """A class that downloads YouTube videos and captions

    Notes
    -----
    - The files are available only after being downloaded in their entirety.
    """

    proxies: typing.Dict[str, str] = None
    use_oauth: bool = False
    allow_oauth_cache: bool = True
    lang_code: str = "en"
    file_extension: str = ".mp4"
    resolution: VideoResolution = VideoResolution.highest

    def __post_init__(self) -> None:
        if self.proxies is None:
            self.proxies = {}

    def _download_caption(
        self, data: YouTube, output_dirpath: str
    ) -> typing.Optional[pathlib.Path]:
        """It downloads the caption of a YouTube video in the given language to the given dirpath

        Returns
        -------
            The filepath to the saved caption or None

        Notes
        -----
        - The filename is the same as the video's with .srt extension.
        """
        caption_str = None
        caption_filepath = None

        # The captions that have automatically generated by YouTube
        # are prepended by an 'a.' prefix in the lang code
        for code in [self.lang_code, f"a.{self.lang_code}"]:
            caption = data.captions.get(code)

            if caption is not None:
                try:
                    caption_str = caption.generate_srt_captions()
                except KeyError:
                    caption_str = caption.xml_captions
                    caption_str = xml_caption_to_srt(caption_str)

                caption_filename = f"{slugify(data.title)}.srt"
                caption_filepath = os.path.join(output_dirpath, caption_filename)
                caption_filepath = pathlib.Path(caption_filepath)

                with caption_filepath.open("wt") as f:
                    f.write(caption_str)

                break

        return caption_filepath

    def _download_video(
        self, data_src: str, output_dirpath: str, filename: typing.Optional[str] = None
    ) -> typing.Tuple[pathlib.Path, YouTube]:
        """It downloads the YouTube video at the given src
        (either video Id or URL) to the given dirpath

        Returns
        -------
        The filepath to the saved video and Pytube core object

        Notes
        -----
        - If the src is a video Id it will be converted to URL beforehand
        - The filename defaults to the slugified title of the video.
        """
        if not validators.url(data_src):
            # video Id to URL
            data_src = _URL_youtube + data_src

        if not data_src.startswith(_URL_youtube):
            raise ValueError("The URL does not point to a valid YouTube video")

        data = YouTube(
            data_src,
            proxies=self.proxies,
            use_oauth=self.use_oauth,
            allow_oauth_cache=self.allow_oauth_cache,
        )

        data.check_availability()

        # It extracts the MIME subtype
        subtype = self.file_extension.replace(".", "")

        streams = data.streams.filter(subtype=subtype)
        stream = _choose_stream(streams, self.resolution)

        filename = f"{slugify(stream.title)}{self.file_extension}"
        filepath = stream.download(output_dirpath, filename)
        filepath = pathlib.Path(filepath)

        return filepath, data

    def download(
        self,
        data_src: strOrPath,
        output_dirpath: strOrPath,
        filename: typing.Optional[strOrPath] = None,
    ) -> YouTubeVideoMetadata:
        """It downloads the YouTube video at the given data source
        (either video Id or URL), and its caption to the given dirpath

        Returns
        -------
            The downloaded video metadata

        Notes
        -----
        - The network call may use proxy servers to hide the IP address.
        - The network call may be OAuth cached
        """
        data_src = str(data_src)
        output_dirpath = str(output_dirpath)
        filename = str(filename)

        filepath, data = self._download_video(data_src, output_dirpath, filename)
        caption_filepath = self._download_caption(data, output_dirpath)

        publish_datetime = data.publish_date
        duration = float(data.length)

        return YouTubeVideoMetadata(
            filepath,
            caption_filepath,
            duration,
            data.author,
            data.description,
            data.keywords,
            publish_datetime,
            data.rating,
            data.title,
            data.views,
        )
